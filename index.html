<!DOCTYPE html>
<html lang="es">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Componente Inteligencia Artificial</title>
        <link rel="stylesheet" href="styles.css"> <!-- Enlace al archivo CSS -->
    </head>
    
    <body>
        <div>
            <h1>Clase 15 de Agosto</h1>
            <h2>Webinar Tecnologías para la transformación Digital: "Capítulo Ciberseguridad e Inteligencia Artificial"</h2>

            <h3>Ciberseguridad</h3>
            <p>Inicialmente nos mostraron formas en que podemos ser vulerados ciberneticamente, los ataques que podemos encontrar en diferentes aspectos, cómo evitar caer en estos ataques y cómo identificarlos. También encontramos información valiosa acerca el manejo de datos, sensibles, privados, públicos y también la forma en que podemos protegerlos o tener prevención con este tipo de información.</p>

            <h3>Caso Lulo Bank: Computación en la nube e Inteligencia Artificial</h3>
            <p>Se nos presentó el caso de éxito de Lulo Bank y cómo aplicaron la computación en la nube e inteligencia artificial. En este sentido aplicaron la computación en la nube para crear un banco totalmente digital que pudiera competir mano a mano con bancos tradicionales, se mencionó que Lulo Bank no tiene sedes físicas así que todo el manejo financiero, informático y de información se maneja online, y los usuarios pueden acceder a todos los servicios que brindan a través de una aplicación móvil. También implementaron la inteligencia artificial de forma que automatice procesos, aprenda sobre el comportamiento comercial de los usuarios y de esta forma pueda sugerir acciones en las cuentas de los usuarios o incluso evitar posibles fraudes o ataques. </p>

            <h3>Concepto Inteligencia Artificial</h3>
            <p>Podemos definir a la inteligencia artificial como sistemas capaces de realizar tareas específicas de manera autonoma. Teniendo esto en cuenta las tareas que una inteligencia artificial puede llevar a cabo reconocer y analizar patrones, toma de desiciones basadas en estos patrones, resolver problemas específicos, aprender e incluso comprender el lenguaje natural.</p>

            <p>
                Inscripción a cursos UNAD:
                <a href="https://estudios.unad.edu.co/programas-ofertados">Cursos Ofertados por la UNAD.</a>
            </p>
        </div>
        
        <div>
            <h1>Clase 22 de Agosto</h1>
            <h2>Inteligencia Artificial y Algoritmos de Búsqueda</h2>

            <h3>¿Qué es inteligencia artificial?</h3>
            <p>Se entiende por inteligencia artificial la capacidad de un sistema o conjunto de tecnolgías de tener la autonomía y adaptabilidad para lograr un determinado objetivo, de comprender, analizar, o realizar tareas sin la supervisión directa de un humano. </p>

            <h3>Algoritmos de búsqueda</h3>
            <p>Los algoritmos de búsqueda son conjuntos de instrucciones o pasos asignados para encontrar un elemento en determinado contexto. Los elementos que pueden ser buscados son nodos, datos, encontrar el mejor camino, el mejor movimiento, etc.</p>

            <h3>Tipos de algoritmos de busqueda</h3>
            <p>Existen multiples tipos de algoritmos de búsqueda que emplearán una técnica distinta para encontrar el elemento de una u otra forma, de manera que son más eficientes para ciertos contextos.</p>

            <p>Algunos de los tipos de algoritmos de búsqueda son:</p>

            <ul>
                <li>Método FIFO (“First In, First Out”): Este algoritmo consiste en que el primer elemento en entrar es el primero en salir.</li>
                <p></p>
                <li>Método LIFO (“Last In, First Out”): Por el contrario, en este algoritmo se observa  que el último elemento en entrar es el primero en salir.</li>
                <p></p>
                <li>Método Depth First Search (Búsqueda en profundidad): Es un algoritmo que recorre todos los nodos de un grafo, de forma que cuando ya no quedan más nodos por visitar en dicho camino regresa al nodo predecesor y continuando con el mismo proceso hasta encontr el fin.</li>
                <p></p>
                <li>Método Breadth First Search (Búsqueda en anchura): En este algoritmo se recorren los nodos de un grafo comenzando desde la raíz para luego explorar cada uno de los vecinos, luego los vecinos explorar sus respectivos vecinos adyacentes hasta que alguno de ellos encuenntra el fin.</li>
            </ul>
        </div>

        <div>
            <h1>Clase 29 de Agosto</h1>
            <h2>Redes Neuronales"</h2>

            <p>
                Enlace a google colab del trabajo realizado sobre redes neuronales:
                <a href="https://colab.research.google.com/drive/1a1GiMzTBgMzd5mNtU0s8PRblPTdVC1J2?usp=sharing">Código Google Colab Redes Neuronales.</a>
            </p>
        </div>

        <div>
            <h1>Parcial 26 de Septiembre</h1>

            <h2>Punto 3. Tabla de resultados obtenidos con algoritmo de python para 3 laberintos.</h2>
            <table border="1">
                <tr>
                  <th>Laberinto</th>
                  <th>Algoritmo</th>
                  <th>Estados Explorados</th>
                  <th>Longitud de la Solución</th>
                  <th>Eficiencia General</th>
                </tr>
                <tr>
                  <td rowspan="2">Laberinto Grupo2</td>
                  <td>DFS</td>
                  <td>504</td>
                  <td>43</td>
                  <td>Menor eficiencia en exploración, ya que DFS explora profundamente, no garantiza el camino óptimo.</td>
                </tr>
                <tr>
                  <td>BFS</td>
                  <td>504</td>
                  <td>43</td>
                  <td>Explora más ampliamente, pero garantiza el camino más corto, aunque con más tiempo de ejecución.</td>
                </tr>
                <tr>
                  <td rowspan="2">Laberinto Grupo1</td>
                  <td>DFS</td>
                  <td>425</td>
                  <td>38</td>
                  <td>Similar comportamiento a BFS, aunque puede explorar caminos más largos inicialmente.</td>
                </tr>
                <tr>
                  <td>BFS</td>
                  <td>425</td>
                  <td>38</td>
                  <td>Mejor para encontrar el camino óptimo, pero con más estados revisados si el camino es largo.</td>
                </tr>
                <tr>
                  <td rowspan="2">Laberinto WhatsApp</td>
                  <td>DFS</td>
                  <td>298</td>
                  <td>29</td>
                  <td>Eficiente en este laberinto pequeño, pero podría no encontrar el camino más corto en otros casos.</td>
                </tr>
                <tr>
                  <td>BFS</td>
                  <td>298</td>
                  <td>29</td>
                  <td>Más eficiente para laberintos pequeños, garantizando el camino más corto sin sobreexploración.</td>
                </tr>
              </table>              

              <div>
                <h2>Punto 4. Código de Red Neuronal en Google Colab Comentado</h2>
                <pre>
                    <code>
            import tensorflow as tf
            # Se importa el paquete TensorFlow y se le asigna el alias 'tf'.
            
            import numpy as np
            # Se importa el paquete NumPy y se le asigna el alias 'np'. 
            
            celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float)
            # Se crea un arreglo de números que representan temperaturas en grados Celsius utilizando la función 'np.array' de NumPy.
            
            fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float)
            # Se crea un arreglo de números que representan temperaturas en grados Fahrenheit utilizando la función 'np.array'.
            
            oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1])
            # Se crea una capa "dense" (fully connected) con 3 neuronas ('units=3') utilizando la API de Keras de TensorFlow.
            # 'input_shape=[1]' especifica que la entrada tiene una sola característica (un solo valor por dato de entrada).
            
            oculta2 = tf.keras.layers.Dense(units=3)
            # Se crea una segunda capa densa con 3 neuronas. 
            # No es necesario definir el 'input_shape' aquí, ya que se deduce automáticamente de la capa anterior.
            
            salida = tf.keras.layers.Dense(units=1)
            # Se define la capa de salida con una sola neurona ('units=1'), que generará la predicción del modelo.
            
            modelo = tf.keras.Sequential([oculta1, oculta2, salida])
            # Se crea el modelo secuencial de Keras, que consiste en una pila de capas definidas anteriormente.
            # Las capas se apilan en el orden en que son mencionadas: primero 'oculta1', luego 'oculta2', y finalmente la capa 'salida'.
            
            modelo.compile(
                optimizer=tf.keras.optimizers.Adam(0.1),
                # Se compila el modelo especificando el optimizador y la función de pérdida.
                # El optimizador utilizado es Adam, que es un algoritmo de optimización eficiente para el entrenamiento de redes neuronales.
                # El parámetro '0.1' es la tasa de aprendizaje (learning rate), que controla qué tan grande es el paso que el optimizador
                # da en cada actualización de los pesos del modelo.
            
                loss='mean_squared_error'
                # La función de pérdida que se usará es el 'mean_squared_error' (error cuadrático medio).
                # Esta función mide la diferencia entre las predicciones del modelo y los valores reales, siendo útil para problemas de regresión.
            )
            
            print("Comenzando entrenamiento...")
            # Imprime un mensaje en la consola indicando que el entrenamiento del modelo está por comenzar.
            
            historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False)
            # Entrena el modelo utilizando los datos de entrada ('celsius') y las etiquetas de salida ('fahrenheit').
            # El modelo ajustará sus parámetros a lo largo de 1000 épocas ('epochs=1000'), donde cada época es un ciclo completo sobre los datos de entrenamiento.
            # 'verbose=False' significa que no se mostrará información detallada sobre el proceso de entrenamiento en cada época.
            # El resultado del entrenamiento (el historial de métricas) se almacena en la variable 'historial'.
            
            print("Modelo entrenado!")
            # Imprime un mensaje en la consola indicando que el modelo ha sido entrenado con éxito.
            
            import matplotlib.pyplot as plt
            # Se importa la biblioteca Matplotlib y se le asigna el alias 'plt'.
            # Matplotlib es utilizada para crear gráficos y visualizaciones de datos en Python.
            
            plt.xlabel("# Epoca")
            # Establece la etiqueta del eje x del gráfico como "# Epoca", indicando que este eje representará el número de épocas.
            
            plt.ylabel("Magnitud de pérdida")
            # Establece la etiqueta del eje y del gráfico como "Magnitud de pérdida", indicando que este eje representará el valor de la pérdida (error).
            
            plt.plot(historial.history["loss"])
            # Se grafica la evolución de la pérdida a lo largo de las épocas. 'historial.history["loss"]' contiene los valores de la función de pérdida
            # para cada época durante el entrenamiento del modelo.
            # El gráfico mostrará cómo el error (pérdida) disminuye conforme avanza el entrenamiento.
            
            print("Hagamos una predicción!")
            # Imprime un mensaje en la consola indicando que se va a realizar una predicción con el modelo entrenado.
            
            resultado = modelo.predict([100.0])
            # Utiliza el método 'predict' del modelo para hacer una predicción. 
            # Se pasa un arreglo con el valor 100.0 como entrada, que corresponde a una temperatura en grados Celsius.
            # El modelo devuelve una predicción de la temperatura correspondiente en grados Fahrenheit.
            
            print("El resultado es " + str(resultado) + " fahrenheit!")
            # Imprime el resultado de la predicción, convirtiendo el valor de 'resultado' a una cadena con 'str()' para poder concatenarlo con el mensaje.
            # El mensaje final muestra el valor predicho en grados Fahrenheit.
            
            print("Variables internas del modelo")
            # Imprime un mensaje en la consola indicando que se van a mostrar las variables internas (pesos) del modelo.
            
            #print(capa.get_weights())
            # Esta línea está comentada y no se ejecutará. Si estuviera activa, intentaría obtener y mostrar los pesos de una capa llamada 'capa'.
            # El método 'get_weights()' devuelve los pesos y sesgos de la capa, que son los parámetros que el modelo ajusta durante el entrenamiento.
            
            print(oculta1.get_weights())
            # Llama al método 'get_weights()' en la primera capa oculta ('oculta1') para obtener y mostrar sus pesos y sesgos.
            # Esto permitirá ver cómo el modelo ha aprendido a representar la relación entre la entrada (Celsius) y la salida (Fahrenheit).
            
            print(oculta2.get_weights())
            # Llama al método 'get_weights()' en la segunda capa oculta ('oculta2') para obtener y mostrar sus pesos y sesgos.
            # Esto mostrará los parámetros de la segunda capa oculta del modelo.
            
            print(salida.get_weights())
            # Llama al método 'get_weights()' en la capa de salida ('salida') para obtener y mostrar sus pesos y sesgos.
            # Esto permitirá ver cómo la capa de salida está configurada para transformar la representación interna en la predicción final.
                    </code>
                </pre>
            </div>            

        </div>

    </body>

    
</html>